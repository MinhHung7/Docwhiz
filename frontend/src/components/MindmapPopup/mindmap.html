<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Mind Map</title>
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='mindmap.css') }}"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  </head>
  <body>
    <div class="container">
      <div class="toolbar">
        <h1>🧠 Interactive Mind Map</h1>
        <div class="controls">
          <button class="btn" onclick="toggleInput()">📝 Input JSON</button>
          <button class="btn" onclick="loadSample()">🎯 Load Sample</button>
          <button class="btn" onclick="resetView()">🔄 Reset View</button>
        </div>
      </div>

      <div class="input-area" id="inputArea">
        <textarea
          id="jsonInput"
          placeholder='Enter JSON data like:
{
  "Machine Learning": {
    "Supervised Learning": {
      "Classification": {},
      "Regression": {}
    },
    "Unsupervised Learning": {
      "Clustering": {},
      "Dimensionality Reduction": {}
    }
  }
}'
        ></textarea>
        <div style="margin-top: 10px">
          <button class="btn" onclick="generateMindMap()">
            🚀 Generate Mind Map
          </button>
          <button class="btn" onclick="toggleInput()">❌ Close</button>
        </div>
      </div>

      <div id="mindmap"></div>

      <div class="zoom-controls">
        <div class="zoom-btn" onclick="zoomIn()">+</div>
        <div class="zoom-btn" onclick="zoomOut()">-</div>
        <div class="zoom-btn" onclick="resetView()">⌂</div>
      </div>

      <div class="tooltip" id="tooltip"></div>
      <div class="loading" id="loading" style="display: none">
        Loading mind map...
      </div>
    </div>

    <script>
      let svg, g, root, tree, zoom;
      let width = window.innerWidth - 40;
      let height = window.innerHeight - 200;
      let i = 0;
      let duration = 750;
      let isHoveringCard = false;
      let isHoveringNode = false;
      let cardTimeout = null;
      let zoomEnabled = true;

      // Initialize SVG
      function initializeSVG() {
        d3.select("#mindmap").selectAll("*").remove();

        svg = d3
          .select("#mindmap")
          .append("svg")
          .attr("width", width)
          .attr("height", height);

        // Define gradient
        const defs = svg.append("defs");
        const gradient = defs
          .append("linearGradient")
          .attr("id", "nodeGradient")
          .attr("x1", "0%")
          .attr("y1", "0%")
          .attr("x2", "100%")
          .attr("y2", "100%");

        gradient
          .append("stop")
          .attr("offset", "0%")
          .attr("stop-color", "#4a90e2");

        gradient
          .append("stop")
          .attr("offset", "100%")
          .attr("stop-color", "#357abd");

        // Create zoom behavior
        zoom = d3
          .zoom()
          .scaleExtent([0.1, 5])
          .wheelDelta(function (event) {
            return zoomEnabled ? -event.deltaY * zoomConfig.wheelSpeed : 0;
          })
          .on("zoom", (event) => {
            g.attr("transform", event.transform);
          });

        svg.call(zoom);

        g = svg.append("g");

        // Create tree layout
        tree = d3
          .tree()
          .size([height - 100, width - 200])
          .separation((a, b) => {
            return (a.parent == b.parent ? 1 : 2) / a.depth;
          });
      }

      // Toggle input area
      function toggleInput() {
        const inputArea = document.getElementById("inputArea");
        inputArea.classList.toggle("active");
      }

      // Load sample data
      function loadSample() {
        document.getElementById("loading").style.display = "block";

        fetch("/api/sample")
          .then((response) => response.json())
          .then((data) => {
            document.getElementById("loading").style.display = "none";
            createMindMap(data);
          })
          .catch((error) => {
            document.getElementById("loading").style.display = "none";
            console.error("Error:", error);
            alert("Error loading sample data: " + error.message);
          });
      }

      // Generate mind map from JSON input
      function generateMindMap() {
        const jsonInput = document.getElementById("jsonInput").value;

        if (!jsonInput.trim()) {
          alert("Please enter JSON data");
          return;
        }

        try {
          const data = JSON.parse(jsonInput);
          document.getElementById("loading").style.display = "block";

          fetch("/api/mindmap", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(data),
          })
            .then((response) => response.json())
            .then((result) => {
              document.getElementById("loading").style.display = "none";
              if (result.status === "success") {
                createMindMap(result.data);
                toggleInput();
              } else {
                alert("Error: " + result.message);
              }
            })
            .catch((error) => {
              document.getElementById("loading").style.display = "none";
              console.error("Error:", error);
              alert("Error generating mind map: " + error.message);
            });
        } catch (error) {
          alert("Invalid JSON format: " + error.message);
        }
      }

      // Create mind map visualization
      function createMindMap(data) {
        initializeSVG();

        root = d3.hierarchy(data);
        root.x0 = height / 2;
        root.y0 = 0;

        // Collapse all nodes except root initially
        if (root.children) {
          root.children.forEach(collapse);
        }

        update(root);

        // Center the view
        const bounds = g.node().getBBox();
        const fullWidth = width;
        const fullHeight = height;
        const midX = bounds.x + bounds.width / 2;
        const midY = bounds.y + bounds.height / 2;

        const scale =
          0.8 / Math.max(bounds.width / fullWidth, bounds.height / fullHeight);
        const translate = [
          fullWidth / 2 - scale * midX,
          fullHeight / 2 - scale * midY,
        ];

        svg
          .transition()
          .duration(750)
          .call(
            zoom.transform,
            d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
          );
      }

      // Collapse node
      function collapse(d) {
        if (d.children) {
          d._children = d.children;
          d._children.forEach(collapse);
          d.children = null;
        }
      }

      // Update visualization
      function update(source) {
        const nodes = root.descendants();
        const nodeCount = nodes.length;
        const treeHeight = Math.max(500, nodeCount * 50);

        tree.size([treeHeight, width - 200]); // dynamically adjust tree height
        const treeData = tree(root);

        const nodesNew = treeData.descendants();
        const links = nodesNew.slice(1);

        nodesNew.forEach((d) => {
          d.y = d.depth * 180;
        });

        // Update nodes
        const node = g
          .selectAll("g.node")
          .data(nodes, (d) => d.id || (d.id = ++i));

        const nodeEnter = node
          .enter()
          .append("g")
          .attr("class", "node")
          .attr("transform", (d) => `translate(${source.y0},${source.x0})`)
          .on("click", click)
          .on("mouseenter", (event, d) => {
            if (cardTimeout) clearTimeout(cardTimeout);
            isHoveringNode = true;
            showTooltip(event, d);
          })
          .on("mouseleave", () => {
            isHoveringNode = false;
            if (cardTimeout) clearTimeout(cardTimeout);
            cardTimeout = setTimeout(() => {
              if (!isHoveringNode && !isHoveringCard) {
                hideTooltip();
              }
            }, 3000);
          });

        nodeEnter
          .append("circle")
          .attr("r", 1e-6)
          .style("fill", (d) => (d._children ? "#ffa726" : "#ffffff"));

        nodeEnter
          .append("foreignObject")
          .attr("width", 150)
          .attr("height", 100)
          .attr("x", -75) // center the box
          .attr("y", -40)
          .append("xhtml:div")
          .style("color", "#333")
          .style("text-align", "center")
          .style("font-size", "12px")
          .style("font-family", "Segoe UI, sans-serif")
          .html((d) => {
            const title = `<strong>${d.data.name || ""}</strong>`;
            // const content = d.data.content
            //   ? `<div>${d.data.content}</div>`
            //   : "";
            return title;
          });

        // Update existing nodes
        const nodeUpdate = nodeEnter.merge(node);

        nodeUpdate
          .transition()
          .duration(duration)
          .attr("transform", (d) => `translate(${d.y},${d.x})`);

        nodeUpdate
          .select("circle")
          .attr("r", (d) => {
            if (d.depth === 0) return 25;
            return d._children ? 18 : 15;
          })
          .style("fill", (d) => {
            if (d.depth === 0) return "#ff6b6b";
            return d._children ? "#ffa726" : "#ffffff";
          })
          .style("stroke", (d) => {
            if (d.depth === 0) return "#ff4757";
            return d._children ? "#ff9800" : "#4a90e2";
          })
          .attr("class", (d) => {
            if (d.depth === 0) return "root-node";
            return d._children ? "collapsed-node" : "expanded-node";
          });

        nodeUpdate
          .select("text")
          .style("fill-opacity", 1)
          .style("font-size", (d) => (d.depth === 0 ? "16px" : "14px"))
          .style("font-weight", (d) => (d.depth === 0 ? "700" : "500"))
          .text((d) => {
            const maxLength = d.depth === 0 ? 20 : 15;
            return d.data.name.length > maxLength
              ? d.data.name.substring(0, maxLength) + "..."
              : d.data.name;
          });

        // Remove exiting nodes
        const nodeExit = node
          .exit()
          .transition()
          .duration(duration)
          .attr("transform", (d) => `translate(${source.y},${source.x})`)
          .remove();

        nodeExit.select("circle").attr("r", 1e-6);

        nodeExit.select("text").style("fill-opacity", 1e-6);

        // Update links
        const link = g.selectAll("path.link").data(links, (d) => d.id);

        const linkEnter = link
          .enter()
          .insert("path", "g")
          .attr("class", "link")
          .attr("d", (d) => {
            const o = { x: source.x0, y: source.y0 };
            return diagonal(o, o);
          });

        const linkUpdate = linkEnter.merge(link);

        linkUpdate
          .transition()
          .duration(duration)
          .attr("d", (d) => diagonal(d, d.parent));

        const linkExit = link
          .exit()
          .transition()
          .duration(duration)
          .attr("d", (d) => {
            const o = { x: source.x, y: source.y };
            return diagonal(o, o);
          })
          .remove();

        // Store old positions for transition
        nodes.forEach((d) => {
          d.x0 = d.x;
          d.y0 = d.y;
        });
      }

      // Diagonal path generator
      function diagonal(s, d) {
        const path = `M ${s.y} ${s.x}
                         C ${(s.y + d.y) / 2} ${s.x},
                           ${(s.y + d.y) / 2} ${d.x},
                           ${d.y} ${d.x}`;
        return path;
      }

      // Click handler
      function click(event, d) {
        if (d.children) {
          d._children = d.children;
          d.children = null;
        } else {
          d.children = d._children;
          d._children = null;
        }
        update(d);
      }

      // Tooltip functions
      function showTooltip(event, d) {
        const tooltip = document.getElementById("tooltip");
        const contentCard = document.getElementById("contentCard");

        if (d.data.content) {
          // Nếu có content: chỉ hiển thị contentCard
          contentCard.innerHTML = `
      <h3>${d.data.name}</h3>
      <p>${d.data.content}</p>
    `;
          contentCard.style.display = "block";

          // Tính toán vị trí card
          const cardWidth = 300;
          const x = event.pageX + 20;
          const y = event.pageY - 20;
          const rightEdge = window.innerWidth - cardWidth - 20;

          contentCard.style.left =
            (x > rightEdge ? event.pageX - cardWidth - 20 : x) + "px";
          contentCard.style.top = y + "px";

          // Không hiển thị tooltip mặc định
          tooltip.style.opacity = 0;
        } else {
          // Nếu KHÔNG có content: hiển thị tooltip như cũ
          tooltip.innerHTML = `
      <strong>${d.data.name}</strong><br>
      Level: ${d.depth}<br>
      Children: ${
        d.children ? d.children.length : d._children ? d._children.length : 0
      }
    `;
          tooltip.style.left = event.pageX + 10 + "px";
          tooltip.style.top = event.pageY - 10 + "px";
          tooltip.style.opacity = 1;

          // Ẩn content card nếu đang mở
          contentCard.style.display = "none";
        }
      }

      function hideTooltip() {
        document.getElementById("tooltip").style.opacity = 0;
        document.getElementById("contentCard").style.display = "none";
      }

      // Zoom configuration
      const zoomConfig = {
        speed: 1.3, // Tốc độ zoom mỗi lần click (1.3 = 30% mỗi lần)
        duration: 200, // Thời gian transition (ms)
        wheelSpeed: 0.002, // Tốc độ zoom bằng mouse wheel
        resetDuration: 500, // Thời gian reset view
      };

      // Zoom functions
      function zoomIn() {
        svg
          .transition()
          .duration(zoomConfig.duration)
          .call(zoom.scaleBy, zoomConfig.speed);
      }

      function zoomOut() {
        svg
          .transition()
          .duration(zoomConfig.duration)
          .call(zoom.scaleBy, 1 / zoomConfig.speed);
      }

      function resetView() {
        svg
          .transition()
          .duration(zoomConfig.resetDuration)
          .call(zoom.transform, d3.zoomIdentity);
      }

      // Handle window resize
      window.addEventListener("resize", () => {
        width = window.innerWidth - 40;
        height = window.innerHeight - 200;

        if (svg) {
          svg.attr("width", width).attr("height", height);
          tree.size([height - 100, width - 200]);
          if (root) update(root);
        }
      });

      // Initialize on page load
      document.addEventListener("DOMContentLoaded", () => {
        initializeSVG();
        loadSample(); // Load sample data on startup

        // NEW: xử lý hover cho contentCard
        const contentCard = document.getElementById("contentCard");

        // Ngăn zoom khi đang cuộn trong contentCard
        contentCard.addEventListener("wheel", function (e) {
          e.stopImmediatePropagation(); // chặn d3.zoom
        });

        contentCard.addEventListener("mouseenter", () => {
          zoomEnabled = false;
        });

        contentCard.addEventListener("mouseleave", () => {
          zoomEnabled = true;
        });
      });
      // Check if mouse is over content card
      function isMouseOverCard(event) {
        const card = document.getElementById("contentCard");
        const rect = card.getBoundingClientRect();
        return (
          event.clientX >= rect.left &&
          event.clientX <= rect.right &&
          event.clientY >= rect.top &&
          event.clientY <= rect.bottom
        );
      }

      // Listen to mouse move globally
      document.addEventListener("mousemove", (event) => {
        if (isMouseOverCard(event)) {
          isHoveringCard = true;
          if (cardTimeout) clearTimeout(cardTimeout);
        } else {
          isHoveringCard = false;
          if (!isHoveringNode) {
            if (cardTimeout) clearTimeout(cardTimeout);
            cardTimeout = setTimeout(() => {
              hideTooltip();
            }, 500); // Giảm từ 3000ms xuống 500ms
          }
        }
      });
    </script>
    <div class="content-card" id="contentCard"></div>
  </body>
</html>
